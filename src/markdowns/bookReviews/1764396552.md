# “Working Effectively with Legacy Code” by Michael C. Feathers

***Completed Reading November 29th 2025***

This book is an oldie but a goodie that I usually revisit every half-decade to ensure I’m following traditional techniques in order to ensure that when I encounter legacy code through my day-to-day job, I can find quick wins in refactoring the codebase if necessary.

Throughout my career, I’ve worked with multiple codebases. Some are pretty straightforward to follow, and others usually take me a while to understand what is going on. I came from a Java background, so my mentality is usually following best practices with OOP (Object-Oriented Programming) and SOLID (Single-responsibility, Open-closed, Liskov substitution, Interface segregation, and Dependency inversion) principles. This book essentially covers how to untangle legacy code to get to a point where the development team can implement proper OOP and SOLID principles.

Since the edition I have was written in 2005 (when I was still in high school), I will say the culture around testing and following best practices for a particular language has become embedded in a lot of companies (well… at least the ones I have worked at). This book, even though it’s still valuable, seems a bit antiquated in how legacy code should be handled. Here’s my reasoning.

Today, with the adoption of Cloud Infrastructure services such as AWS, GCP, and Azure, there are a lot of tools that massively help with decoupling. Coming from a more AWS lexicon, Serverless Lambda and Step Functions have made it easier to split key functionality into their own standalone process. So, for example, if I have a system with an API service, a UI, a Database, and some ETL/cron jobs, before cloud infrastructure, a development team would usually have at most one repository/codebase for the frontend logic and one service that handled the backend logic with additional auxiliary operations. The coupling in that backend service could become a tangled mess as more and more features were added to the codebase (hypothetically). But with tools like Serverless Lambda/Step Function, those ETL/cron jobs can be extracted out, and the development can have procedural code that handles one key function in the system.

Also, this book doesn’t really dive into monolithic vs. microservices to also help with decoupling logic from a macro level (depending on the team’s circumstances). As a heads up, this book primarily focuses on making legacy code easier to implement OOP/SOLID standards. So for languages like Rust or Haskell (more procedural languages), it’s not necessarily ideal compared to programming in Java, C++, or PHP.

I would be interested to see the updates Michael C. Feathers would make to this book in the current technical landscape.
